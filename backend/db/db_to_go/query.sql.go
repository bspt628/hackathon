// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createBlock = `-- name: CreateBlock :execresult
INSERT INTO blocks (id, blocked_by_id, blocked_user_id)
VALUES (?, ?, ?)
`

type CreateBlockParams struct {
	ID            string `json:"id"`
	BlockedByID   string `json:"blocked_by_id"`
	BlockedUserID string `json:"blocked_user_id"`
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) (sql.Result, error) {
	return q.exec(ctx, q.createBlockStmt, createBlock, arg.ID, arg.BlockedByID, arg.BlockedUserID)
}

const createDM = `-- name: CreateDM :execresult
INSERT INTO dms (id, sender_id, receiver_id, content)
VALUES (?, ?, ?, ?)
`

type CreateDMParams struct {
	ID         string `json:"id"`
	SenderID   string `json:"sender_id"`
	ReceiverID string `json:"receiver_id"`
	Content    string `json:"content"`
}

func (q *Queries) CreateDM(ctx context.Context, arg CreateDMParams) (sql.Result, error) {
	return q.exec(ctx, q.createDMStmt, createDM,
		arg.ID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Content,
	)
}

const createFollow = `-- name: CreateFollow :execresult
INSERT INTO follows (id, follower_id, following_id)
VALUES (?, ?, ?)
`

type CreateFollowParams struct {
	ID          string `json:"id"`
	FollowerID  string `json:"follower_id"`
	FollowingID string `json:"following_id"`
}

func (q *Queries) CreateFollow(ctx context.Context, arg CreateFollowParams) (sql.Result, error) {
	return q.exec(ctx, q.createFollowStmt, createFollow, arg.ID, arg.FollowerID, arg.FollowingID)
}

const createLike = `-- name: CreateLike :execresult
INSERT INTO likes (id, user_id, tweet_id)
VALUES (?, ?, ?)
`

type CreateLikeParams struct {
	ID      string `json:"id"`
	UserID  string `json:"user_id"`
	TweetID string `json:"tweet_id"`
}

func (q *Queries) CreateLike(ctx context.Context, arg CreateLikeParams) (sql.Result, error) {
	return q.exec(ctx, q.createLikeStmt, createLike, arg.ID, arg.UserID, arg.TweetID)
}

const createReply = `-- name: CreateReply :execresult
INSERT INTO replies (id, user_id, tweet_id, content)
VALUES (?, ?, ?, ?)
`

type CreateReplyParams struct {
	ID      string `json:"id"`
	UserID  string `json:"user_id"`
	TweetID string `json:"tweet_id"`
	Content string `json:"content"`
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) (sql.Result, error) {
	return q.exec(ctx, q.createReplyStmt, createReply,
		arg.ID,
		arg.UserID,
		arg.TweetID,
		arg.Content,
	)
}

const createRetweet = `-- name: CreateRetweet :execresult
INSERT INTO retweets (id, user_id, tweet_id)
VALUES (?, ?, ?)
`

type CreateRetweetParams struct {
	ID      string `json:"id"`
	UserID  string `json:"user_id"`
	TweetID string `json:"tweet_id"`
}

func (q *Queries) CreateRetweet(ctx context.Context, arg CreateRetweetParams) (sql.Result, error) {
	return q.exec(ctx, q.createRetweetStmt, createRetweet, arg.ID, arg.UserID, arg.TweetID)
}

const createTweet = `-- name: CreateTweet :execresult
INSERT INTO tweets (id, user_id, content)
VALUES (?, ?, ?)
`

type CreateTweetParams struct {
	ID      string `json:"id"`
	UserID  string `json:"user_id"`
	Content string `json:"content"`
}

func (q *Queries) CreateTweet(ctx context.Context, arg CreateTweetParams) (sql.Result, error) {
	return q.exec(ctx, q.createTweetStmt, createTweet, arg.ID, arg.UserID, arg.Content)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (id, username, email, password, status)
VALUES (?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	ID       string         `json:"id"`
	Username string         `json:"username"`
	Email    string         `json:"email"`
	Password string         `json:"password"`
	Status   sql.NullString `json:"status"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.exec(ctx, q.createUserStmt, createUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Status,
	)
}

const deleteBlock = `-- name: DeleteBlock :exec
DELETE FROM blocks
WHERE blocked_by_id = ? AND blocked_user_id = ?
`

type DeleteBlockParams struct {
	BlockedByID   string `json:"blocked_by_id"`
	BlockedUserID string `json:"blocked_user_id"`
}

func (q *Queries) DeleteBlock(ctx context.Context, arg DeleteBlockParams) error {
	_, err := q.exec(ctx, q.deleteBlockStmt, deleteBlock, arg.BlockedByID, arg.BlockedUserID)
	return err
}

const deleteFollow = `-- name: DeleteFollow :exec
DELETE FROM follows
WHERE follower_id = ? AND following_id = ?
`

type DeleteFollowParams struct {
	FollowerID  string `json:"follower_id"`
	FollowingID string `json:"following_id"`
}

func (q *Queries) DeleteFollow(ctx context.Context, arg DeleteFollowParams) error {
	_, err := q.exec(ctx, q.deleteFollowStmt, deleteFollow, arg.FollowerID, arg.FollowingID)
	return err
}

const deleteLike = `-- name: DeleteLike :exec
DELETE FROM likes
WHERE id = ?
`

func (q *Queries) DeleteLike(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteLikeStmt, deleteLike, id)
	return err
}

const deleteRetweet = `-- name: DeleteRetweet :exec
DELETE FROM retweets
WHERE id = ?
`

func (q *Queries) DeleteRetweet(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteRetweetStmt, deleteRetweet, id)
	return err
}

const deleteTweet = `-- name: DeleteTweet :exec
UPDATE tweets
SET is_deleted = TRUE
WHERE id = ?
`

func (q *Queries) DeleteTweet(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteTweetStmt, deleteTweet, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, id)
	return err
}

const getProfile = `-- name: GetProfile :one
SELECT id, user_id, bio, location, website, is_private FROM profiles
WHERE user_id = ? LIMIT 1
`

func (q *Queries) GetProfile(ctx context.Context, userID string) (Profile, error) {
	row := q.queryRow(ctx, q.getProfileStmt, getProfile, userID)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Bio,
		&i.Location,
		&i.Website,
		&i.IsPrivate,
	)
	return i, err
}

const getTweet = `-- name: GetTweet :one
SELECT id, user_id, content, created_at, is_deleted FROM tweets
WHERE id = ? LIMIT 1
`

func (q *Queries) GetTweet(ctx context.Context, id string) (Tweet, error) {
	row := q.queryRow(ctx, q.getTweetStmt, getTweet, id)
	var i Tweet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.CreatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, email, password, created_at, status FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const listDMs = `-- name: ListDMs :many
SELECT id, sender_id, receiver_id, content, created_at FROM dms
WHERE (sender_id = ? AND receiver_id = ?) OR (sender_id = ? AND receiver_id = ?)
ORDER BY created_at DESC
LIMIT ?
`

type ListDMsParams struct {
	SenderID     string `json:"sender_id"`
	ReceiverID   string `json:"receiver_id"`
	SenderID_2   string `json:"sender_id_2"`
	ReceiverID_2 string `json:"receiver_id_2"`
	Limit        int32  `json:"limit"`
}

func (q *Queries) ListDMs(ctx context.Context, arg ListDMsParams) ([]Dm, error) {
	rows, err := q.query(ctx, q.listDMsStmt, listDMs,
		arg.SenderID,
		arg.ReceiverID,
		arg.SenderID_2,
		arg.ReceiverID_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Dm{}
	for rows.Next() {
		var i Dm
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, user_id, type, message, created_at, is_read FROM notifications
WHERE user_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListNotificationsParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) ListNotifications(ctx context.Context, arg ListNotificationsParams) ([]Notification, error) {
	rows, err := q.query(ctx, q.listNotificationsStmt, listNotifications, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Message,
			&i.CreatedAt,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReplies = `-- name: ListReplies :many
SELECT id, user_id, tweet_id, content, created_at FROM replies
WHERE tweet_id = ?
ORDER BY created_at
`

func (q *Queries) ListReplies(ctx context.Context, tweetID string) ([]Reply, error) {
	rows, err := q.query(ctx, q.listRepliesStmt, listReplies, tweetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reply{}
	for rows.Next() {
		var i Reply
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TweetID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTweets = `-- name: ListTweets :many
SELECT id, user_id, content, created_at, is_deleted FROM tweets
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListTweets(ctx context.Context, userID string) ([]Tweet, error) {
	rows, err := q.query(ctx, q.listTweetsStmt, listTweets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tweet{}
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password, created_at, status FROM users
ORDER BY username
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.CreatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications
SET is_read = TRUE
WHERE id = ?
`

func (q *Queries) MarkNotificationAsRead(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.markNotificationAsReadStmt, markNotificationAsRead, id)
	return err
}

const updateProfile = `-- name: UpdateProfile :exec
UPDATE profiles
SET bio = ?, location = ?, website = ?, is_private = ?
WHERE user_id = ?
`

type UpdateProfileParams struct {
	Bio       sql.NullString `json:"bio"`
	Location  sql.NullString `json:"location"`
	Website   sql.NullString `json:"website"`
	IsPrivate bool           `json:"is_private"`
	UserID    string         `json:"user_id"`
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) error {
	_, err := q.exec(ctx, q.updateProfileStmt, updateProfile,
		arg.Bio,
		arg.Location,
		arg.Website,
		arg.IsPrivate,
		arg.UserID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET username = ?, email = ?, password = ?, status = ?
WHERE id = ?
`

type UpdateUserParams struct {
	Username string         `json:"username"`
	Email    string         `json:"email"`
	Password string         `json:"password"`
	Status   sql.NullString `json:"status"`
	ID       string         `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Status,
		arg.ID,
	)
	return err
}
